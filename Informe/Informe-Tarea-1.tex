\documentclass[letterpaper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fontenc}
\usepackage[dvipdfmx]{graphicx}
\usepackage{bmpsize,wrapfig,xcolor}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}

% Para evitar que se indente solo a cada rato
\setlength\parindent{0pt}

\begin{document}
	\begin{titlepage}

		\begin{wrapfigure}{R}{0.3\textwidth}
			\includegraphics[width=0.3\textwidth]{logoFCFM.png}
		\end{wrapfigure}

		\noindent \phantom - % "Hax" para que quede alineada la imagen con el texto

		Universidad de Chile

		Facultad de Ciencias Físicas y Matemáticas

		Depto. de Ciencias de la Computación

		CC4102 - Diseño y Análisis de Algoritmos

		\vfill

		\begin{center}
			\begin{Huge}
				{\textbf{Tarea 1}}
			\end{Huge}
		\end{center}

		\vfill

		\begin{flushright}
			\begin{tabular}{lll}
				Integrantes	&:	& Rodrigo Delgado\\
						&	& Belisario Panay\\
						&	& Gabriel Sanhueza\\
				Profesor	&:	& Gonzalo Navarro\\
				Ayudante	&:	& Sebastián Ferrada\\
				Auxiliar	&:	& Jorge Bahamondes\\
			\end{tabular}
		\end{flushright}

	\end{titlepage}

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\tableofcontents

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Introducción}

	\subsection{Problema a resolver}

	Los R-trees son un tipo de árbol que se maneja en memoria secundaria, el cual contiene rectángulos como información. El problema a resolver consiste en implementar un R-Tree,
	una herramienta de búsquedas de rectángulos y 2 heurísticas de inserción de rectángulos en el R-Tree.

	En particular, se busca evaluar el impacto entre distintas versiones de \textit{inserción} que manejan una versión específica de manejo de \textit{overflow} (para este caso,
	\textit{Linear Split} y \textit{Greene Split}.

	\subsection{Hipótesis}

	\subsubsection*{Especificaciones de la máquina utilizada}

	\begin{itemize}
		\item Procesador: Intel \textregistered Core \textregistered i7-6700HQ @ 2.60GHz
		\item Arquitectura: x86\_64
		\item Número de CPUs: 4
		\item Número de Threads: 8
		\item Memoria RAM: 12288 KB
		\item Tamaño de página de disco: M = 4096 bytes ($\ulcorner40\% M\urcorner = 1638$)
		\item Sistema Operativo: Arch Linux 4.8.6
		\item Lenguaje usado: C
		\item Compilador: gcc version 6.2.1
	\end{itemize}

	Usaremos siempre la misma semilla de aleatoriedad, para poder tener experimentos ``aleatorios'' repetibles.

	Limitamos la cantidad máxima de rectángulos en un nodo con respecto al tamaño de página del disco.

	Así, si \textit{BLOCK\_SIZE} = 4096 y tenemos un \textit{struct rectangle} llamado \textit{Rectangle}:

	\begin{itemize}
		\item M = \textit{BLOCK\_SIZE / sizeof(struct rectangle)} = $ 4096 / 32 = 128 $
		\item m = 40\% de M. = $ 40\% * 128 = 51 $
	\end{itemize}

	Por último, la idea es nunca tener más de dos archivos abiertos en un instante dado.

	A partir de esto, consideramos que la inserción tome un tiempo corto con pocos rectángulos y se incremente notablemente a medida que se añaden unos cuantos más.
	Además, esperamos que la búsqueda se demore menos que la inserción.

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Diseño Experimental}

	\subsection{Metodología}

	Para cada $n \in \{2^{9}, ..., 2^{18}\}$, se harán 3 experimentos, 3 veces cada uno:

	\begin{itemize}
		\item Inserción de \textit{n} rectángulos, control de \textit{overflow} con Linear Split.
		\item Inserción de \textit{n} rectángulos, control de \textit{overflow} con Greene Split.
		\item Búsqueda de \textit{n/10} rectángulos.
	\end{itemize}

	\subsection{Structs}

	En nuestra implementación hicimos 2 \textit{structs} para manejar los rectángulos en el R-Tree.

	\subsubsection{Rectangle}

	Esta estructura posee información sobre:
	\begin{itemize}
		\item Coordenada X.
		\item Coordenada Y.
		\item Ancho del rectángulo.
		\item Alto del rectángulo.
		\item Identificador (nombre) del rectángulo.
		\item Identificador del hijo de este rectángulo.
	\end{itemize}

	\subsubsection{Node}

	Esta estructura posee información sobre:
	\begin{itemize}
		\item Arreglo dinámico de rectángulos.
		\item Número de rectángulos escritos en el arreglo.
		\item Nombre del nodo actual (para uso como nombre de archivo en disco).
	\end{itemize}

	\subsection{Constantes}

	\begin{itemize}
		\item \textbf{BLOCK\_SIZE:} Tamaño del bloque en disco.
		\item \textbf{count}: Variable global para diferenciar nodos al escribirlos a disco.
		\item \textbf{M}: BLOCK\_SIZE / sizeof(Rectangle) --- Máximo número de rectángulos en un nodo.
		\item \textbf{m}: 40\% de M --- Mínimo número de rectángulos en un nodo.
	\end{itemize}

	\subsection{Funciones}

	\begin{itemize}
		\item \textit{Rectangle* createRectangle(int x, int y, int w, int h, int id)}: Crea un rectángulo con coordenadas y nombre.
		\item \textit{Node* createNode()}: Crea un nodo con un arreglo de rectángulos como información interna.
		\item \textit{writeToDisk(Node *data)}: Escribe los datos de un nodo a disco.
		\item \textit{Node* loadFromDisk(char *filename)}: Carga un archivo del disco.
		\item \textit{int intersect (Rectangle *r1, Rectangle *r2)}: Retorna un "booleano" que dice si los dos rectángulos se intersectan.
		\item \textit{int MBR(Rectangle *r1, Rectangle *r2)}: Calcula la nueva Area si se agrega r2 a r1.
		\item \textit{void mergeRectangle(Rectangle *r1, Rectangle *r2)}: Actualiza las coordenadas de r1 al agregarle r2. (Solo las actualiza, no añade r2 a r1).
		\item \textit{int partitionX(Node *header,int inicio,int final)}: Funcion auxiliar para quicksort, eje X.
		\item \textit{int partitionY(Node *header,int inicio,int final)}: Funcion auxiliar para quicksort, eje Y.
		\item \textit{void quicksort(Node *header,int inicio,int final,int d)}: Quicksort para rectángulos.
		\item \textit{Rectangle **makeRandom(Node pNode)}: Desordena el orden de los rectángulos de un nodo para aleatorizar el split.
		\item \textit{void printRectangle(Rectangle *r)}: Imprime información de un rectángulo.
		\item \textit{Rectangle **calculateXRectangles(Node *pNode)}: Calcula los rectangulos con mayor bajo y menor alto en un arreglo para el eje X e Y.
		\item \textit{int *calculateBounds(Node *pNode)}: Calcula el rectángulo más grande de todos los que están en el nodo.
		\item \textit{int randomNum(int max)}: Retorna un número aleatorio acotado.
		\item \textit{Rectangle ** bateriaRectangulos(int n)}: Crea n rectángulos distintos para experimentación.
		\item \textit{Rectangle **copy(Rectangle **pRectangle, int n)}: Copia un arreglo de n elementos.
		\item \textit{Node *search(char *nodeName, Rectangle *rect)}: Busca en el nodo todos los rectángulos que intersectan a *rect.
		\item \textit{void insertToRootLinear(char *nodeName, Rectangle *r)}: Inserción Linear Split con control de Overflow en Root.
		\item \textit{void insertToRootGreene(char* nodeName, Rectangle *r)}: Inserción Greene Split con control de Overflow en Root.
		\item \textit{void insertLinear(char *nodeName , Rectangle *r)}: Inserción Linear Split con control de Overflow en el resto de los nodos.
		\item \textit{void insertGreene(char *nodeName, Rectangle *r)}: Inserción Greene Split con control de Overflow en el resto de los nodos.
		\item \textit{Rectangle ** linearSplit(Node *header)}: Control de overflow usando Linear Split.
		\item \textit{Rectangle ** greeneSplit(Node *header)}: Control de overflow usando Greene Split.
	\end{itemize}

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Presentación de los Resultados}
	%	TODO Presentación de los Resultados

	\subsection{Tiempo de Construcción del R-Tree}
	\subsubsection{Linear Split}
	% 	TODO Linear Split

	\begin{center}

		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			Rectángulos	& Exp. 1 (segs) & Exp. 2 (segs) & Exp. 3 (segs) & Min & Max & Prom & Desv. Est\\
			\hline
			$2^{9}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{10}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{11}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{12}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{13}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{14}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{15}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{16}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{17}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{18}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
		\end{tabular}

		\includegraphics{logoFCFM.png}
	\end{center}

	\subsubsection{Greene Split}
	% 	TODO Greene Split

	\begin{center}

		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			Rectángulos	& Exp. 1 (segs) & Exp. 2 (segs) & Exp. 3 (segs) & Min & Max & Prom & Desv. Est\\
			\hline
			$2^{9}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{10}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{11}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{12}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{13}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{14}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{15}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{16}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{17}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{18}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
		\end{tabular}

		\includegraphics{logoFCFM.png}
	\end{center}

	\subsection{Espacio ocupado y porcentaje de llenado de páginas de disco}
% 	TODO Espacio ocupado disco

	Porcentaje de llenado = avgsize(nodes)/max(nodes)

	\begin{center}

		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			Rectángulos	& Espacio ocupado (bytes) & Nodos & Tamaño promedio & Tamaño Máximo & \% llenado por nodo\\
			\hline
			$2^{9}$ 	& 1 & 2 & 3 & 4 & 5\%\\
			\hline
			$2^{10}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{11}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{12}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{13}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{14}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{15}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{16}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{17}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
			$2^{18}$ 	& 1 & 2 & 3 & 4 & 5\\
			\hline
		\end{tabular}

		\includegraphics{logoFCFM.png}
	\end{center}

	\subsection{Desempeño de operación \textit{Buscar}}
% 	TODO Desempeño de buscar

	\begin{center}

		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			Rectángulos	& Exp. 1 (segs) & Exp. 2 (segs) & Exp. 3 (segs) & Min & Max & Prom & Desv. Est\\
			\hline
			$2^{9}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{10}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{11}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{12}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{13}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{14}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{15}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{16}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{17}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
			$2^{18}$ 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 	& 50 \\
			\hline
		\end{tabular}

		\includegraphics{logoFCFM.png}
	\end{center}

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Análisis e Interpretación}
% 	TODO Análisis e Interpretación

	\subsection{Linear Split}

	Encontramos que linear split se demora caleta (?)

	\subsection{Greene Split}

	Encontramos que greene split se demora caleta (?)

	\subsection{Buscar}

	Encontramos que la búsqueda se demora caleta (?)

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Conclusiones}

	TODO

\end{document}
